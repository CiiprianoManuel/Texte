using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace exercicio15_sequencia
{
    class Program
    {
        public static int[] vetor;
        static void Main(string[] args)
        {
            vetor = new int[20];
            for (int i = 0; i < vetor.Length; i++)
            {
                Console.Write("|"+i+"|Digite:(");
                vetor[i] = int.Parse(Console.ReadLine());
            }

            Console.Write(sequencia());
            Console.ReadKey();
        }
        public static string sequencia()
        {
            int n = 0, cont = 0, reber = 0, ind = 0;
            string mostrar="";
            while (n < vetor.Length)
            {
                if (n == vetor.Length - 1)
                {
                    if (cont > reber)
                    {
                        reber = cont;
                        ind = n - reber;
                    }
                mostrar = "O primeiro Indice ==" + ind + " Com o tamanho ==" + (reber+1);
                }
                else
                {
                    if (vetor[n] + 1 == vetor[n + 1])
                    {
                        cont++;
                    }
                    if (vetor[n] + 1 != vetor[n + 1])
                    {
                        if (cont > reber)
                        {
                            reber = cont;
                            ind = n - reber;
                        }

                        cont = 0;
                    }
                    
                }
                n++;
            }
           return mostrar;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace horas
{
    class Program
    {
        static void Main(string[] args)
        {
            int H=0, M=0, S=0;
            Console.Write("Digite Hora(s):(");
            H = int.Parse(Console.ReadLine());
            Console.Write("Digite Minuto(s):(");
            M = int.Parse(Console.ReadLine());
            Console.Write("Digite Segundo(s)");
            S = int.Parse(Console.ReadLine());
            while (M > 60 || S > 60|| H>24)
            {
                    if (S >=60)
                    {
                        S -= 60;
                        M++;
                    }
                    if (M >= 60)
                    {
                        M -= 60;
                        H++;
                    }
                if (H >= 24)
                {
                    H -= 24;
                }
            }
            Console.Clear();
            Console.Write($"\n\nH=={H} M=={M} S=={S}");
            Console.ReadKey();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Eliminar_utimo_elementovetor
{
    class Program
    {
         static public  int[] Desloca; 
        static void Main(string[] args)
        {
            Desloca = new int[10];
            for (int i = 0; i < Desloca.Length; i++)
            {
                Console.WriteLine("Valor M");
                Desloca[i] = int.Parse(Console.ReadLine());
            }
            Console.WriteLine("Posição");
            int posicao = int.Parse(Console.ReadLine());
            Console.WriteLine("Digite sub");
            int subist = int.Parse(Console.ReadLine());
            Valor(posicao, subist);
            foreach (int item in Desloca)
            {
                Console.Write(item);
            }
            Console.ReadKey();
            }
            static public int[] Valor(int posica, int subist)
            {
            for (int i = Desloca.Length-1; i >=posica ; i--)
            {
                Desloca[i] = Desloca[i - 1];
            }
            Desloca[posica] = subist;
            return Desloca;
           }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace exercicio_5
{
    class Program
    {
        static void Main(string[] args)
        {
            int L = 4, C = 4;
            string[,] Agrupa = new string[L,C]; string[,] Receber = new string[L, C];
            string[] Provincias = { "*Luanda*", "*Benguela*", "*Huambo*", "*Uige*" };//, "Cabinda", "Malange", "Zaire", "Namibe", "Huila", "Kwanza-Sul" };
            string[] SIGLA = { "LU", "BE", "HA", "UI" };//, "CB", "MA", "ZA", "NA", "HU", "KW" };
            Console.WriteLine("\t\t\t\t\t\t\tAs iniciais\n(*Luanda*)-LU\n(*Benguela*)-BE\n(*Benguela*)-HA\n(*Uige*)-UI");
            for (int i = 0; i < L; i++)
            {
                for (int x = 0; x < C; x++)
                {
                    Console.Write("\n\n\t\t\t\t\tIndereço:(");
                    string BD = Console.ReadLine();
                    BD = BD.ToUpper();
                    for (int b = 0; b < SIGLA.Length; b++)
                    {
                        if (BD.Contains(SIGLA[b]))
                        {
                            Agrupa[i, x] = BD;
                            b = SIGLA.Length;
                        }
                        else if (b == SIGLA.Length - 1)
                        {
                            Console.WriteLine("Provincia Não identificada, Valor não salvo");
                        }
                    }
                }
            }
            ////////////////////////////////////
            int control = 0, fim = 0, Dentro = 0;
            while (fim < Agrupa.Length)
            {
                for (int i = L - 1; i >= 0; i--)
                {
                    for (int x = C - 1; x >= 0; x--)
                    {
                        while (Dentro < SIGLA.Length - 1)
                        {
                        if(control==SIGLA.Length) { control = 0;}
                            if (Agrupa[i,x].ToUpper().Contains(SIGLA[control]) != false)
                            {
                                Receber[i, control] = Agrupa[i,x];
                                fim++;
                                control = 0;
                                Dentro = SIGLA.Length;
                            }
                            else
                            { control++; }
                                Dentro++;
                            }
                            Dentro = 0;
                        }
                    }
                }
            for (int i = 0; i < L; i++)
            {
                Console.WriteLine(Provincias[i]);
                for (int x  = 0; x  < C; x ++)
                {
                if(Receber[x,i]!=null)
                 {
                        Console.WriteLine(Receber[x, i]);
                    }
                }
            }

                Console.ReadKey();
            }
        }
    }

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace matris_superio_doGrupo
{
    class Program
    {
        static void Main(string[] args)
        {
            int[,] Mt1;
            int limet = 0, cont = 0;
            Console.Write("digite L1:(");
            int L1 = int.Parse(Console.ReadLine());
            Console.Write("Digite L2:(");
            int L2 = int.Parse(Console.ReadLine());
            if (L1 == L2)
            {
                Mt1 = new int[L1, L2];
                for (int i = 0; i < L1; i++)
                {
                    for (int y = 0; y < L2; y++)
                    {
                        Console.Write("Digite:(");
                        Mt1[i, y] = int.Parse(Console.ReadLine());
                    }
                }

                for (int i = 0; i < L1; i++)
                {
                    for (int y = 0; y < L2; y++)
                    {
                        if (i > 0)
                        {
                            if (limet < cont)
                            {
                                Mt1[i,y] = 0;
                                Console.WriteLine($"|{i}|{y}|=={Mt1[i,y]}");
                            }
                            limet++;
                            if (limet == L1 || limet == L2) { limet = 0; }
                        }
                        else { Console.WriteLine($"|{i}|{y}|=={Mt1[i,y]}"); }
                    }
                    cont++;
                }
               
            }
            else Console.WriteLine("Calculo deve ser inicializado com valores da matriz iguais");
            Console.ReadKey();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace aulas
{
    class Program
    {
       public static int L,L1, C, C1;
       public static int[,] receber;
       public static int[,] Matriz ;
       public static int[,] Matriz1 ;
        
        static void Main(string[] args)
        {
         
            Console.Write("Digite 1º L(:");
             L = int.Parse(Console.ReadLine());
            Console.Write("Digite 1º C:(");
             C = int.Parse(Console.ReadLine());

            Console.Write("Digite 2º L(:");
             L1 = int.Parse(Console.ReadLine());
            Console.Write("Digite 2º C:(");
             C1 = int.Parse(Console.ReadLine());
            Matriz = new int[L, C];
            Matriz1 = new int[C, L];
            if (C != L1) {//Condiçao da matriz
                Console.WriteLine("Matrizes deferente");Console.ReadKey();return;
            }
            else
            { if(L == C1 && L1 == C)
                {
                    receber = new int[L+C1,L1+C];
                }
               else { receber = new int[L1,L1]; }
              //  receber = new int[L1, L1];
            }//Fim da condição
         
            ////////Primeira Matriz
            for (int i = 0; i < L; i++)
            {
                for (int y1 = 0; y1 < C; y1++)
                {
                    Console.WriteLine($"|{i}|{y1}|");
                    Console.Write($"Digite valor 1º Matriz");
                    Matriz[i,y1] = int.Parse(Console.ReadLine());
                }
            }//////////////Fim
           //seguda Matriz
            for (int i = 0; i < L1; i++)
            {
                for (int y2 = 0; y2 < C1; y2++)
                {
                    Console.WriteLine($"|{i}|{y2}|");
                    Console.Write("Digite valor 2º Matriz");
                    Matriz1[i, y2] = int.Parse(Console.ReadLine());
                }
            }//////////////Fim

            foreach (var item in MT())
            {
                Console.WriteLine(item);
            }
          
            Console.ReadKey(); 
        }
        public static int [] MT()
        {
            int[] mostrar = new int[C+L1];
            int x = 0, cont = 0, para = 0,control=0,p=0;
            while (true)
            {
                /////////////////////////////////// ciclo infinito
                if (para == Matriz1.Length + Matriz.Length)
                {
                    //  return mostrar;
                    return mostrar;
                }//
                for (int i = 0; i < L; i++)
                {
                    for (int y = 0; y < C; y++)
                    {/////////para depois de completo
                       //////// Fim parar
                        para++;
                        if (cont >= Matriz.Length) { x++; cont = 0; }
                        receber[i, y] = Matriz[i, y] * Matriz1[y,x];
                        cont++;
                        //  Console.WriteLine(receber[i, y]);
                        ///////falta
                        if(control==L)
                        {
                            p++;
                            control = 0;
                        }
                        if (control < L)
                        {
                            mostrar[p]+= receber[i, y];
                        }
                        control++;
                        /////////////////////////////////////////// 
                    }
                }////////////////////////////////Fim infinito
            }
        }
            
        }
    }

